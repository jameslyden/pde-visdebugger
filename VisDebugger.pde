/* Visualization tool for Arduino Debugger
 * Setup with same baud rate as the target Arduino
 * NOTE: there is no provision for pushing non-debug data back on the serial line
 * TODO: Re-implement data store as ring buffer object
 */

// Initialize global data structures
import processing.serial.*;
Serial port = new Serial(this, Serial.list()[0], 9600);

int packetOverhead = 6; // packet overhead, including header, CRC, etc
int packetSize = 7;		// packet size, initial value assumes 1 channel
int channels;				// Number of channels
int chanHeight;			// Height of each channel
int paddedChanHeight;	// Height of each channel after padding
String[] chanName;		// Stores autogenerated name of each channel
boolean[] chanDigital;	// Stores flag for digital/analog treatment of each channel
float zoom = 1.0f;		// controls zoom levels
int[][] value;				// data storage for all channels, all samples
int currSample = 0;		// points to column in value that represents the current time

int currReadTime = 0;	// for interval tracking
int lastReadTime = 0;			
int readInterval = 0; 

// Initialize global constants
final int windowHeight = 960;		// Height of overall window
final int windowWidth = 1280;		// Width of overall window
final int headerHeight = 20;		// Height of header section for text output
final int lGutterWidth = 64;		// Width of left gutter for text output
final int rGutterWidth = 64;		// Width of right gutter for text output
final int footerHeight = 12;		// Height of footer section for text output
final int chanPadding = 2;			// Unused pixels at the top and bottom of each channel
final float voltFactor = 0.05;	// Volts per unit, for analog channels
final int maxSamples = 40960;		// 40k samples is roughly 10-60 seconds worth
											// (depending on total analog channel count)
final int canvasHeight = windowHeight - headerHeight - footerHeight;
final int canvasWidth = windowWidth - lGutterWidth - rGutterWidth;

final int debugLevel = 6;			// controls output of console debug messages

/* void setup() -- mandatory initialization function
 * 
 * setup() constructs the UI, syncs to the serial stream, and configures the
 * channel count/types. At completion, control is handed to draw() for 
 * continuous data/UI updates.
 */
void setup() 
{
	// construct window and enable 4xAA
	size(windowWidth, windowHeight);
	smooth(4);

	// init local variables
	int debugDataSize = 0;
	int CRCcalc = 0;  
	int CRCsent = -1;
	int[] initValue;
	int dChannelCount = 0;
	int aChannelCount = 0;

	// Use initial data set to configure channels
	printDebug(1, "Initializing program.");
	port.clear();
	do {
		// wait for at least 6 bytes (minimum packet size) to arrive
		printDebug(2, "Waiting for packet...");
		while (!identifyPacket());

		// initialize variables dependent on channel count
		debugDataSize = port.read();
		channels = debugDataSize - packetOverhead;
		printDebug(3, channels + " channels detected.");
		chanHeight = (canvasHeight / channels);
		paddedChanHeight = chanHeight - (chanPadding * 2);
		initValue = new int[channels];
		chanName = new String[channels];
		chanDigital = new boolean[channels];

		// get initial interval timing data
		readInterval = port.read();
		lastReadTime = millis();

		// read channel values into initValue and determine A/D status and names
		for (int i = 0; i < channels; i++) {
			initValue[i] = port.read();
			// treat as digital if value is 250 or 251
			if ((initValue[i] == 250) || (initValue[i] == 251)) {
				chanName[i] = new String("DIG-" + dChannelCount++);
				chanDigital[i] = true;
			}
			else {
				chanName[i] = new String("ANA-" + aChannelCount++);
				chanDigital[i] = false;
			}
			printDebug(4, "Added " + chanName[i] + " (value " + initValue[i] + ").");
		}

		// Build 8-bit CRC from payload
		printDebug(3, "Calculating CRC...");
		CRCsent = port.read();
		for (int i = 0; i < channels; i++) {
			CRCcalc = CRCcalc + initValue[i];
			CRCcalc = CRCcalc % 256;
		}
		CRCcalc = CRCsent;  //FIXME: CRC calculations stopped working for unknown reason

		if (CRCcalc != CRCsent)
			printDebug(3, "CRC mismatch, " + CRCcalc + "/" + CRCsent + ". Starting over.");
	} while (CRCcalc != CRCsent);
	printDebug(3, "CRC matches.");
	printDebug(2, "Packet read. Initializing data store..."); 

	// Initialize data store for all samples
	value = new int[channels][maxSamples];
	packetSize = debugDataSize;
	printDebug(1, "Initialization complete.");
}

/* void draw() -- mandatory loop function
 * 
 * draw() initiates a data update followed by a UI update. The UI update is a
 * complete refresh of all UI elements at every pass (including header/footer
 * and other relatively static data). Note that operator inputs are handled
 * by interrupt, which triggers the built-in keyReleased() function.
 */
void draw()
{
		readNewData();
		redrawScreen();
}

/* void readNewData() -- get new samples from serial port (blocking call)
 * 
 * readNewData() performs header ID, parsing, and CRC validation. If the new
 * data is acceptable, the data store and current sample pointer are updated.
 * readNewData() will not return to the calling function until a valid packet
 * is received.
 */
void readNewData()
{
	// init local variables
	int debugDataSize = 0;
	int CRCcalc = 0;  
	int CRCsent = -1;
	int[] tempValue = new int[channels];

	// Use initial data set to configure channels
	printDebug(1, "Getting new serial data.");
	do {
		// wait for at least 6 bytes (minimum packet size) to arrive
		printDebug(3, "Waiting for packet...");
		while (!identifyPacket());

		// get size and timing data
		debugDataSize = port.read();
		readInterval = port.read();
		currReadTime = millis();

		// save channel values into tempValue until CRC is validated
		for (int i = 0; i < channels; i++) {
			tempValue[i] = port.read();
			printDebug(5, "Received " + tempValue[i] + " for " + chanName[i] + ".");
		}

		// Build 8-bit CRC from payload
		printDebug(4, "Calculating CRC...");
		CRCsent = port.read();
		for (int i = 0; i < channels; i++) {
			CRCcalc = CRCcalc + tempValue[i];
			CRCcalc = CRCcalc % 256;
		}
		if (CRCcalc != CRCsent)
			printDebug(3, "CRC mismatch, " + CRCcalc + "/" + CRCsent + ". Starting over.");
	} while (CRCcalc != CRCsent);
	printDebug(4, "CRC matches.");
	printDebug(3, "Packet read. Adding to data store..."); 

	// Manage currSample pointer to maintain ring buffer
	if (++currSample >= maxSamples) {
		currSample = 0;
		printDebug(3, "Ring buffer index rolled over.");
	}
	// Transfer contents of tempValue to next slot in data store
	for (int i = 0; i < channels; i++) {
		value[i][currSample] = tempValue[i];
		printDebug(5, "Inserted " + value[i][currSample] + " into value[" + i + "][" + currSample + "].");
	}

	// update interval data
	lastReadTime = currReadTime;
	printDebug(1, "Finished getting serial data.");
}

/* void redrawScreen() -- update the UI with new sample data
 * 
 * << complete the description >>
 */
void redrawScreen()
{
	// create basic grid first
	background(24);
	stroke(0);
	line(0, headerHeight, width, headerHeight);
	line(0, height - footerHeight, width, height - footerHeight);
	line(lGutterWidth, 0, lGutterWidth, height);
	line(width - rGutterWidth, 0, width - rGutterWidth, height);
	// then draw channel dividers
	stroke(48);
	for (int i = 0; i < channels; i++) {
		line(lGutterWidth, (i * chanHeight) + headerHeight, rGutterWidth, (i * chanHeight) + headerHeight);
	}

	// temporary output until redrawScreen is written properly
	for (int i = 0; i < channels; i++) {
		textAlign(CENTER, CENTER);
		text(chanName[i], lGutterWidth / 2, (i * chanHeight) + headerHeight + (chanHeight / 2)); 
		textAlign(LEFT, CENTER);
		text(value[i][currSample], lGutterWidth + chanPadding, i * chanHeight + headerHeight + chanPadding); 
	}

	textAlign(CENTER, CENTER);
	String timing = new String(readInterval + " ms");
	text("reported", width - (rGutterWidth / 2), headerHeight + (canvasHeight / 2) - 40);
	text(timing, width - (rGutterWidth / 2), headerHeight + (canvasHeight / 2) - 25);
	int calcInterval = currReadTime - lastReadTime;
	timing = new String(calcInterval + " ms");
	text("observed", width - (rGutterWidth / 2), headerHeight + (canvasHeight / 2) + 25);
	text(timing, width - (rGutterWidth / 2), headerHeight + (canvasHeight / 2) + 40);
}

/* boolean identifyPacket () -- helper to read until valid packet header is found
 *
 * << complete description >>
 */
boolean identifyPacket ()
{
	int data;

	// wait for first header byte, then enough bytes for a complete packet
	port.bufferUntil(255);
	port.buffer(packetOverhead);
/*
	do {
		data = port.read();
		printDebug(6, "read byte: " + data);
	} while (data != 255);

	while (port.available() < packetOverhead) {
		printDebug(6, "bytes available: " + port.available());
	}
*/
	// check for valid header sequence one byte at a time
	printDebug(2, "Inspecting packet...");
	port.buffer(1);
	if (port.read() == 254) {
		port.buffer(1);
		if (port.read() == 253) {
			printDebug(3, "Header correct. Continuing...");
			return true;
		}
	}
	return false;
}

/* int scaleVertical(int) -- helper to map channel value to allotted area
 * 
 * scaleVertical(int uH) takes integer analog or digital sensor value uH, as
 * provided by the Debugger program, and maps it to a sensible scale that will
 * fit within the space allotted to a single channel. For digital values, this
 * means HIGH maps close to the upper bound of the space, while LOW maps close
 * to the lower bound. For analog values, it is a direct linear scaling effect.
 */
int scaleVertical(int unscaledHeight)
{
	int scaledHeight;

	printDebug(6, "scaleVertical called for " + unscaledHeight);
	if (unscaledHeight == 250) {
		scaledHeight = chanPadding;
		printDebug(6, "scaleVertical returning " + scaledHeight + " for LOW.");
	}
	else if (unscaledHeight == 251) {
		scaledHeight = chanHeight - chanPadding;
		printDebug(6, "scaleVertical returning " + scaledHeight + " for HIGH.");
	}
	else {
		float scaleFactor = paddedChanHeight/250.0f;
		scaledHeight = (int)(unscaledHeight * scaleFactor) + chanPadding;
		printDebug(6, "scaleVertical returning " + scaledHeight + " for analog.");
	}

	return scaledHeight;
}

/* void keyReleased() -- built-in keyboard interrupt service routine
 * 
 * keyReleased() is triggered on every key release event. It is used for all
 * UI control, currently consisting of zoom in/zoom out capabilities. This is
 * likely to expand to pause/play and seeking forward/back in the near future.
 */
void keyReleased() 
{
	printDebug(1, "Entering keypress handler.");
	switch (key) {
		case '+':
			zoom *= 2.0f;
			if ((maxSamples / canvasWidth) < zoom)
				zoom /= 2.0f;
			printDebug(2, "Zoom in. Zoom level: " + zoom + ".");		
			break;
		case '-':
			zoom /= 2.0f;
			if ((5 * maxSamples / canvasWidth) < (1 / zoom))
				zoom *= 2.0f;
			printDebug(2, "Zoom out. Zoom level: " + zoom + ".");		
			break;
	}
	printDebug(1, "Leaving keypress handler.");
}

/* void printDebug(int, String) -- print debug message if minimum level met
 * 
 * printDebug(int level, String msg) prints msg to the console if the global
 * debugLevel is set to at least level.
 */
void printDebug(int level, String msg)
{
	if (debugLevel >= level) {
		String timestamp=new String(hour() + ":" + minute() + ":" + second());
		String label=new String(timestamp + "+++D" + level + ": ");
		for (int i = 0; i < level; i++) {
			label=new String(label + "   ");
		}
		println(label + msg);
	}
}

/*
// initialize value to invalid
int[] currValue = new int[channels];
// initialize to size of header
int size = 4;

// process packet
while (port.available() >= size) {
// check for valid header sequence
if (port.read() == 255 && port.read() == 100 && port.read() == 200) {
size = port.read();
currValue[0] = port.read(); //FIXME: only grab first value for display
for (int i = 1; i < size; i++) { //FIXME: i=0 after prev line is removed
port.read(); // FIXME: empties buffer of remainder of payload
}
int CRC = port.read();
}
}
return currValue;
}

void pushValue(int[] currValue) 
{
currSample++;
if (currSample >= maxSamples) {
currSample = 0;
}
//  values[width-1] = value;
}

void drawLines() 
{
background(0);
stroke(250);

int displayWidth = (int) (width / zoom);

//  int k = values.length - displayWidth;
int k = currSample;

int x0 = 0;
int y0 = getY(value[currSample][k]);
for (int i=1; i<displayWidth; i++) {
k++;
int x1 = (int) (i * (width-1) / (displayWidth-1));
int y1 = getY(value[currSample][k]);
line(x0, y0, x1, y1);
x0 = x1;
y0 = y1;
}
}
 */
